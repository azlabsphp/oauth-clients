<?php

declare(strict_types=1);

/*
 * This file is part of the drewlabs namespace.
 *
 * (c) Sidoine Azandrew <azandrewdevelopper@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Drewlabs\Oauth\Clients\OAuth2;

use Drewlabs\Oauth\Clients\Contracts\ClientInterface;
use Drewlabs\Oauth\Clients\Contracts\ClientsRepository as AbstractRepository;
use Drewlabs\Oauth\Clients\Contracts\GrantTypesAware;
use Drewlabs\Oauth\Clients\Contracts\VerifyClientSecretInterface;
use League\OAuth2\Server\Repositories\ClientRepositoryInterface;

class ClientRepository implements ClientRepositoryInterface
{
    /**
     * @var AbstractRepository
     */
    private $clients;

    /**
     * @var VerifyClientSecretInterface
     */
    private $verifyClientSecret;

    /**
     * Creates OAuth2 server client repository.
     */
    public function __construct(AbstractRepository $clients, VerifyClientSecretInterface $verifyClientSecret)
    {
        $this->clients = $clients;
        $this->verifyClientSecret = $verifyClientSecret;
    }

    public function getClientEntity($clientIdentifier)
    {
        $client = $this->clients->findById($clientIdentifier);
        if (null === $client) {
            return null;
        }

        return Client::fromOauthClient($client);
    }

    public function validateClient($clientIdentifier, $clientSecret, $grantType)
    {
        // First, we will verify that the client exists and is authorized to create personal
        // access tokens. Generally personal access tokens are only generated by the user
        // from the main interface. We'll only let certain clients generate the tokens.
        $client = $this->clients->findById($clientIdentifier);

        if (empty($client) || !$this->handlesGrant($client, (string) $grantType)) {
            return false;
        }

        return !$client->isConfidential() || $this->verifyClientSecret->verify($client, $clientSecret);
    }

    /**
     * Determine if the given client can handle the given grant type.
     *
     * @return bool
     */
    protected function handlesGrant(ClientInterface $client, string $grantType)
    {
        if ($client instanceof GrantTypesAware && !\in_array($grantType, $client->getGrantTypes(), true)) {
            return false;
        }

        switch ($grantType) {
            case GrantTypes::AUTHORIZATION_CODE_GRANT:
                return !$client->firstParty();
            case GrantTypes::PERSONAL_ACCESS_GRANT:
                return $client->isConfidential();
            case GrantTypes::PASSWORD_GRANT:
                return $client->isPasswordClient();
            case GrantTypes::CLIENT_CREDENTIALS_GRANT:
                return $client->isConfidential();
            default:
                return true;
        }
    }
}
